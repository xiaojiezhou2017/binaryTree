<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>有序二叉树</title>
  </head>
  <style>
    body {
      color: #fff;
      background: black;
      padding: 20px;
    }
    .box {
      color: #fff;
      height: 30px;
      width: 30px;
      border: 1px solid red;
      position: absolute;
      font-size: 12px;
      border-radius: 50%;
    }
    .line {
      position: absolute;
      border-top: 1px solid red;
      height: 0px;
      width: 150px;
    }
    #circle {
      font-size: 12px;
      color: #fff;
      position: absolute;
      height: 30px;
      width: 30px;
      border-radius: 50%;
      border: 1px solid #fff;
      text-align: center;
      line-height: 30px;
      transform: scale(1.2);
    }
    button {
      outline: none;
      border: none;
      height: 20px;
      width: 100px;
      background: #fff;
      border-radius: 5px;
    }
    input {
      border: 1px solid #fff;
      border-radius: 5px;
      outline: none;
    }
    .jump {
      animation: jump 1s;
    }
    .button-group {
      margin-top: 20px;
    }
    @keyframes jump {
      15% {
        transform: scale(3);
      }
      50% {
        transform: scale(1);
      }
      75% {
        transform: scale(3);
      }
      100% {
        transform: scale(1);
      }
    }
    .console-wrapper {
      width: 500px;
      margin: 0 auto;
    }
    #console {
      display: inline-block;
    }
    .item {
      margin-left: 10px;
      font-size: 20px;
    }
    .button-item {
        margin-top: 30px;
    }
    label {
        font-size: 12px;
    }
  </style>
  <body>
    <div id="circle" style="visibility: hidden"></div>
    <div id="circleOne"></div>
    <label for="value">请输入要插入的值:</label>
    <input
      type="text"
      id="value"
      name="value"
      onchange="handleChange(this.value)"
    />

    <div class="button-group">
      <div class="button-item">
        <button onclick="delMax()">删除最大元素</button>
      </div>
      <div class="button-item">
        <button onclick="handleSort()">演示堆排序</button>
      </div>
    </div>

    <div class="console-wrapper">
      <span>当前数组:</span>
      <div id="console"></div>
    </div>
  </body>
  <script>
    function handleChange(value) {
      push(Number(value));
      render();
    }

    function print(arr) {
      const container = document.querySelector('#console');
      const items = arr.reduce((prev, next, index) => {
        return `${prev}<span class="item">${next}</span>`;
      }, '');
      container.innerHTML = items;
    }

    const FONT_SIZE = 12;
    const SHAPE = '30';
    const LINE_WIDTH = 300;
    const deep = 0;
    const deepMap = {};
    const RATIO = 3;
    const BASE_DEG = 20;
    const SPEED = 0.6;

    // 排序二叉树
    let binaryTree = [''];

    function getDeep() {
      let deep = 1;
      const deepMap = new Map();

      return function(target, value) {
        if (target === undefined) {
          return 0;
        }
        if (deepMap.has(target)) {
          return deepMap.get(target);
        } else {
          deepMap.set(target, deep++);
          return deepMap.get(target);
        }
      };
    }

    const getDeeper = getDeep();

    function appendNode(parent, value = '', dir) {
      const moveStance = SHAPE / 2;
      // text
      const textWrap = document.createElement('span');
      const textNode = document.createTextNode(value);
      textWrap.appendChild(textNode);
      textWrap.style.position = 'absolute';
      textWrap.style.top = moveStance - FONT_SIZE / 2 + 'px';
      textWrap.style.left = moveStance - FONT_SIZE / 2 + 'px';

      if (!parent) {
        const root = document.createElement('div');
        root.setAttribute('class', 'box');
        root.style.left = window.innerWidth / 2 - SHAPE / 2 + 'px';
        document.body.appendChild(root);
        root.appendChild(textWrap);
        return root;
      }
      // 树的深度
      const deep = parent.deep || 1;
      // 每层边长旋转的角度
      const baseDeg = (parent.deg || BASE_DEG) * 1.5;
      //  const baseDeg = BASE_DEG + deep + RATIO;
      // 边的长度
      const lineWidth = (parent.len || LINE_WIDTH) * 0.7;

      const fragment = document.createDocumentFragment();
      const x = 0;
      const y = 0;
      const line = document.createElement('div');
      line.setAttribute('class', 'line');

      const transformDeg =
        dir === 'right' ? `${baseDeg}deg` : `${180 - baseDeg}deg`;
      line.style.width = lineWidth - 15 + 'px';
      line.style.transformOrigin = 'left top';
      // line.style.transform = `rotate(45deg) translateX(${moveStance}px) translateY(${moveStance}px)`;
      line.style.transform = `translateX(${moveStance}px) translateY(${moveStance}px) rotate(${transformDeg})`;

      const child = document.createElement('div');
      child.setAttribute('class', 'box');
      child.appendChild(textWrap);
      child.deep = deep + 1;
      child.len = lineWidth;
      child.deg = baseDeg;

      fragment.appendChild(line);

      const deg = Math.PI / 180;
      const letStance = x + lineWidth * Math.cos(deg * baseDeg);
      const topStance = y + lineWidth * Math.sin(deg * baseDeg);
      if (dir === 'right') {
        child.style.left = letStance + 'px';
      } else if (dir === 'left') {
        child.style.left = -letStance + 'px';
      }
      child.style.top = topStance + 'px';
      fragment.appendChild(child);
      parent.appendChild(fragment);
      return child;
    }

    // 节点交换
    // source { left right value }
    function nodeChange(source, target) {}

    function setPoistion(target, left, top) {
      target.style.left = left + 'px';
      target.style.top = top + 'px';
    }

    function moveByLine(source, target) {
      let { left: sl, top: st, value: sv } = source;
      let { left: tl, top: tt, value: tv } = target;
      const leftDis = Math.abs(sl - tl);
      const topDis = Math.abs(tt - st);
      const dis = Math.sqrt(leftDis ** 2 + topDis ** 2);
      const ele = document.querySelector('#circle');
      ele.style.visibility = 'visible';
      ele.innerHTML = sv;
      const leftDir = leftDis / dis;
      const topDir = topDis / dis;
      const speed = SPEED;
      let leftPos = sl;
      let topPos = st;
      return new Promise((resolve, reject) => {
        const timer = setInterval(() => {
          if (sl < tl) {
            leftPos += speed * leftDir;
          } else {
            leftPos -= speed * leftDir;
          }
          if (st < tt) {
            topPos += speed * topDir;
          } else {
            topPos -= speed * topDir;
          }
          setPoistion(ele, leftPos, topPos);
          if (Math.abs(leftPos - tl) < 3 || Math.abs(topPos - tt) < 3) {
            resolve();
            clearInterval(timer);
          }
        }, 10);
      });
    }
    function exchange(arr, i, j) {
      [arr[i], arr[j]] = [arr[j], arr[i]];
      print(arr);
    }

    const animationList = []; // 动画列表
    let clearList = []; // 动画执行完成，执行清理动作

    function getElement(id) {
      return document.querySelector(`#id-${id}`);
    }

    function getPos(ele) {
      return ele.getBoundingClientRect();
    }

    function setVal(ele, value) {
      ele.querySelector('span').innerHTML = value;
    }

    function hideCircle() {
      document.querySelector('#circle').style.visibility = 'hidden';
    }

    function setTextClass(parent, className) {
      parent.querySelector('span').setAttribute('class', className);
    }
    async function handleOpration(opt) {
      const { type, data } = opt;
      console.log('optation=========>', opt);
      if (opt.type === 'exchange') {
        const sourceValue = data[0];
        const targetValue = data[1];
        const value = data[2];
        const sourceEle = getElement(sourceValue);
        const targetEle = getElement(targetValue);
        const source = getPos(sourceEle);
        const target = getPos(targetEle);
        setTextClass(sourceEle, 'jump');
        setTextClass(targetEle, 'jump');
        source.value = value;
        await moveByLine(source, target);
        setVal(targetEle, value);
        setVal(sourceEle, binaryTree[targetValue]);
        setTextClass(sourceEle, '');
        setTextClass(targetEle, '');
        exchange(binaryTree, sourceValue, targetValue);
      }
      if (opt.type === 'remove') {
        const parent = Math.floor(data / 2);
        const currentDom = getElement(data);
        const parentDom = getElement(parent);
        const lineDom = currentDom.previousSibling;
        parentDom.removeChild(lineDom);
        parentDom.removeChild(currentDom);
      }
    }

    async function render() {
      while (animationList.length) {
        const a = animationList.shift();
        await handleOpration(a);
      }
      hideCircle();
      clearList.forEach(i => i.call(null));
      clearList = [];
    }

    function pushOpration(opt) {
      animationList.push(opt);
    }

    function drawTree(binaryTree) {
      const rootDom = document.querySelector('[data-root="true"]');
      if (rootDom) {
        document.body.removeChild(rootDom);
      }
      function _darwTree(tree, n, parent) {
        if (2 * n + 1 > tree.length) {
          return;
        }
        const leftValue = tree[2 * n];
        const rightValue = tree[2 * n + 1];
        const left = appendNode(parent, leftValue, 'left');
        left.setAttribute('id', 'id-' + 2 * n);
        _darwTree(tree, 2 * n, left);
        if (rightValue !== undefined) {
          const right = appendNode(parent, rightValue, 'right');
          right.setAttribute('id', 'id-' + (2 * n + 1));
          _darwTree(tree, 2 * n + 1, right);
        }
      }
      const root = appendNode(undefined, binaryTree[1]);
      root.setAttribute('id', 'id-' + 1);
      root.setAttribute('data-root', true);
      _darwTree(binaryTree, 1, root);
    }

    drawTree(binaryTree);

    function push(item, isExchange = false) {
      let pos = binaryTree.push(item) - 1;
      print(binaryTree);
      drawTree(binaryTree);
      swim(pos, item, isExchange);
      // drawTree(binaryTree);
    }

    // 上浮一个元素
    function swim(pos, value, isExchange = false) {
      let parentPos;
      let p = pos;
      while ((parentPos = Math.floor(p / 2)) >= 1) {
        parentValue = binaryTree[parentPos];
        if (parentValue < value) {
          if (isExchange) {
            exchange(binaryTree, parentPos, p);
          }
          pushOpration({ data: [p, parentPos, value], type: 'exchange' });
        }
        p = parentPos;
      }
    }

    // 删除根节点, 也就是最大的元素
    function delMax() {
      // binaryTree[1] = 0;
      drawTree(binaryTree);
      const last = binaryTree.length - 1;
      pushOpration({ data: [last, 1, binaryTree[last]], type: 'exchange' });
      pushOpration({ data: last, type: 'remove' });
      clearList.push(() => {
        binaryTree.pop();
      });
      sink(1, binaryTree[binaryTree.length - 1]);
      render();
    }

    function sink(pos, value, len = binaryTree.length) {
      let p = pos;
      while (p * 2 < len) {
        const childPos = 2 * p;
        const childValue = binaryTree[childPos];
        const rightChildValue = binaryTree[childPos + 1] || -Infinity;
        const replace = childValue > rightChildValue ? childPos : childPos + 1;
        if (value >= binaryTree[replace]) {
          break;
        } else {
          // exchange(binaryTree, p, replace);
          pushOpration({ data: [p, replace, value], type: 'exchange' });
        }
        p = replace;
      }
    }

    function handleSort() {
      // 构造堆排序的过程
      binaryTree = Array.apply(null, { length: 15 }).map((i, index) => index);
      shuffle(binaryTree);
      binaryTree[0] = '';
      // binaryTree = ['', 13, 9, 0, 1, 7, 11, 3, 5, 6, 12, 10, 8, 2, 14];
      console.log('binaryTree', binaryTree.slice());

      drawTree(binaryTree);
      function shuffle(arr) {
        const getRange = (min, max) =>
          min + Math.floor((max - min) * Math.random());
        const len = arr.length;
        for (let i = 0; i < len - 1; i++) {
          const exIndex = getRange(i, len);
          exchange(arr, i, getRange(i, len));
        }
      }

      async function sort(arr) {
        let len = arr.length;
        for (let i = Math.floor(len / 2); i >= 1; i--) {
          const value = arr[i];
          sink(i, value, len);
          await render();
        }
        len--;
        while (len >= 1) {
          pushOpration({ data: [len, 1, arr[len]], type: 'exchange' });
          await render();
          len--;
          sink(1, arr[1], len);
          await render();
        }
      }
      print(binaryTree);
      sort(binaryTree);
    }

    /** example for add node
    const root = appendNode(undefined, 1);
    const child = appendNode(root, 2, 'right')
    const child2 = appendNode(root, 3, 'left')
    **/
  </script>
</html>
